function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
/**
 * Manages user account and DID in web based environments.
 *
 * ## Purpose
 *
 * Manages, creates and authorizes a DID session key for a user. Returns an authenticated DIDs instance
 * to be used in other Ceramic libraries. Supports did:pkh for blockchain accounts with Sign-In with
 * Ethereum and CACAO for authorization.
 *
 * ## Installation
 *
 * ```sh
 * npm install @glazed/did-session
 * ```
 *
 * ## Usage
 *
 * Create an instance, authorize and use DIDs where needed. At the moment, only Ethereum accounts
 * are supported with the EthereumAuthProvider. Additional accounts will be supported in the future.
 *
 * ```ts
 * import { DIDSession } from '@glazed/did-session'
 * import { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'
 *
 * const ethProvider = // import/get your web3 eth provider
 * const addresses = await ethProvider.enable()
 * const authProvider = new EthereumAuthProvider(ethProvider, addresses[0])
 *
 * const session = new DIDSession({ authProvider })
 * const did = await session.authorize()
 *
 * // Uses DIDs in ceramic & glaze libraries, ie
 * const ceramic = new CeramicClient()
 * ceramic.did = did
 *
 * // pass ceramic instance where needed
 *
 * ```
 *
 * You can serialize a session to store for later and then re-initialize. Currently sessions are valid
 * for 1 day by default.
 *
 *```ts
 * // Create session as above, store for later
 * const session = new DIDSession({ authProvider })
 * const did = await session.authorize()
 * const sessionString = session.serialize()
 *
 * // write/save session string where you want (ie localstorage)
 * // ...
 *
 * // Later re initialize session
 * const session2 = DIDSession.fromSession(authProvider, sessionString)
 * const ceramic = new CeramicClient()
 * ceramic.did = session2.getDID()
 * ```
 *
 * Additional helper functions are available to help you manage a session lifecycle and the user experience.
 *
 *```ts
 * // Check if authorized or created from existing session string
 * didsession.hasSession
 *
 * // Check if session expired
 * didsession.isExpired
 *
 * // Get resources session is authorized for
 * didsession.authorizations
 *
 * // Check number of seconds till expiration, may want to re auth user at a time before expiration
 * didsession.expiresInSecs
 * ```
 * 
 * ### Typical usage pattern 
 * 
 * A typical pattern is to store a serialized session in local storage and load on use if available. Then 
 * check that a session is still valid before making writes. 
 * 
 * ```ts
 * import { DIDSession } from '@glazed/did-session'
 * import { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'
 *
 * const ethProvider = // import/get your web3 eth provider
 * const addresses = await ethProvider.enable()
 * const authProvider = new EthereumAuthProvider(ethProvider, addresses[0])
 * 
 * const loadSession = async(authProvider: EthereumAuthProvider):Promise<DIDSession> => {
 *  const sessionStr = localStorage.getItem('didsession')
 *  let session
 *  
 *  if (sessionStr) {
 *    session = await DIDSession.fromSession(sessionStr, authProvider)
 *  }
 *  
 *  if (!session || (session.hasSession && session.isExpired)) {
 *    session = new DIDSession({ authProvider })
 *    session.authorize()
 *    localStorage.setItem('didsession', session.serialize())
 *  }
 *  
 *  return session
 * }
 * 
 * const session = await loadSession(authProvider)
 * const ceramic = new CeramicClient()
 * ceramic.did = session.getDID()
 * 
 * // pass ceramic instance where needed, ie glaze 
 * // ...
 * 
 * // before ceramic writes, check if session is still valid, if expired, create new
 * if (session.isExpired) {
 *   const session = loadSession(authProvider)
 *   ceramic.did = session.getDID()
 * }
 * 
 * // continue to write
 * ```
 * 
 * @module did-session
 */ import { Ed25519Provider } from 'key-did-provider-ed25519';
import KeyDidResolver from 'key-did-resolver';
import { randomBytes } from '@stablelib/random';
import { DID } from 'dids';
import * as u8a from 'uint8arrays';
export async function createDIDKey(seed) {
    const didProvider = new Ed25519Provider(seed || randomBytes(32));
    const didKey = new DID({
        provider: didProvider,
        resolver: KeyDidResolver.getResolver()
    });
    await didKey.authenticate();
    return didKey;
}
function JSONToBase64url(object) {
    return u8a.toString(u8a.fromString(JSON.stringify(object)), 'base64url');
}
function base64urlToJSON(s) {
    return JSON.parse(u8a.toString(u8a.fromString(s, 'base64url')));
}
function bytesToBase64(b) {
    return u8a.toString(b, 'base64pad');
}
function base64ToBytes(s) {
    return u8a.fromString(s, 'base64pad');
}
var _authProvider = /*#__PURE__*/ new WeakMap(), _resources = /*#__PURE__*/ new WeakMap(), _did = /*#__PURE__*/ new WeakMap(), _keySeed = /*#__PURE__*/ new WeakMap(), _cacao = /*#__PURE__*/ new WeakMap();
/**
 * DID Session
 *
 * ```sh
 * import { DIDSession } from '@glazed/did-session'
 * ```
 */ export class DIDSession {
    /**
   * Get authProvider
   */ get authProvider() {
        return _classPrivateFieldGet(this, _authProvider);
    }
    /**
   * Request authorization for session
   */ async authorize(capabilityOpts = {}) {
        _classPrivateFieldSet(this, _keySeed, randomBytes(32));
        const didKey = await createDIDKey(_classPrivateFieldGet(this, _keySeed));
        // Pass through opts resources instead, resource arg does not support anything but streamids at moment
        const opts = Object.assign({
            resources: _classPrivateFieldGet(this, _resources)
        }, capabilityOpts);
        _classPrivateFieldSet(this, _cacao, await _classPrivateFieldGet(this, _authProvider).requestCapability(didKey.id, [], opts));
        return this.initDID(didKey, _classPrivateFieldGet(this, _cacao));
    }
    async initDID(didKey, cacao) {
        const didWithCap = didKey.withCapability(cacao);
        await didWithCap.authenticate();
        _classPrivateFieldSet(this, _did, didWithCap);
        return didWithCap;
    }
    /**
   * Get DID instance, if authorized
   */ getDID() {
        if (!_classPrivateFieldGet(this, _did)) {
            throw new Error('DID not available, has not authorized');
        }
        return _classPrivateFieldGet(this, _did);
    }
    /**
   * Serialize session into string, can store and initalize the same session again while valid
   */ serialize() {
        if (!_classPrivateFieldGet(this, _keySeed) || !_classPrivateFieldGet(this, _cacao)) throw new Error('No session to seralize');
        const session = {
            sessionKeySeed: bytesToBase64(_classPrivateFieldGet(this, _keySeed)),
            cacao: _classPrivateFieldGet(this, _cacao)
        };
        return JSONToBase64url(session);
    }
    /**
   * Initialize a session from a serialized session string
   */ static async fromSession(session, authProvider) {
        const { sessionKeySeed , cacao  } = base64urlToJSON(session);
        const dsession = new DIDSession({
            authProvider,
            cacao,
            keySeed: base64ToBytes(sessionKeySeed)
        });
        const didKey = await createDIDKey(_classPrivateFieldGet(dsession, _keySeed));
        await dsession.initDID(didKey, cacao);
        return dsession;
    }
    get hasSession() {
        return !!_classPrivateFieldGet(this, _cacao) && !!_classPrivateFieldGet(this, _did);
    }
    /**
   * Determine if a session is expired or not
   */ get isExpired() {
        if (!_classPrivateFieldGet(this, _cacao)) throw new Error('No session available');
        const expTime = _classPrivateFieldGet(this, _cacao).p.exp;
        if (!expTime) return false;
        return Date.parse(expTime) < Date.now();
    }
    /**
   * Number of seconds until a session expires
   */ get expireInSecs() {
        if (!_classPrivateFieldGet(this, _cacao)) throw new Error('No session available');
        const expTime = _classPrivateFieldGet(this, _cacao).p.exp;
        if (!expTime) throw new Error('Session does not expire');
        const timeDiff = Date.parse(expTime) - Date.now();
        return timeDiff < 0 ? 0 : timeDiff / 1000;
    }
    /**
   * Get the list of resources a session is authorized for
   */ get authorizations() {
        return _classPrivateFieldGet(this, _cacao)?.p.resources ?? [];
    }
    /**
   * Get the session CACAO
   */ get cacao() {
        if (!_classPrivateFieldGet(this, _cacao)) throw new Error('No session available');
        return _classPrivateFieldGet(this, _cacao);
    }
    /**
   * Determine if session is available and optionally if authorized for given resources
   */ isAuthorized(resources) {
        if (!this.hasSession || this.isExpired) return false;
        if (!resources) return true;
        return resources.every((val)=>this.authorizations.includes(val));
    }
    /** DID string associated to the session instance. session.id == session.getDID().parent */ get id() {
        if (!_classPrivateFieldGet(this, _did)) {
            throw new Error('ID not available, has not authorized');
        }
        return _classPrivateFieldGet(this, _did).parent;
    }
    constructor(params){
        _classPrivateFieldInit(this, _authProvider, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _resources, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _did, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _keySeed, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _cacao, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldSet(this, _authProvider, params.authProvider);
        _classPrivateFieldSet(this, _keySeed, params.keySeed);
        _classPrivateFieldSet(this, _cacao, params.cacao);
        _classPrivateFieldSet(this, _resources, params.resources ?? [
            `ceramic://*`
        ]);
    }
}
