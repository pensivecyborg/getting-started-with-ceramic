/**
 * Manages user account and DID in web based environments.
 *
 * ## Purpose
 *
 * Manages, creates and authorizes a DID session key for a user. Returns an authenticated DIDs instance
 * to be used in other Ceramic libraries. Supports did:pkh for blockchain accounts with Sign-In with
 * Ethereum and CACAO for authorization.
 *
 * ## Installation
 *
 * ```sh
 * npm install @glazed/did-session
 * ```
 *
 * ## Usage
 *
 * Create an instance, authorize and use DIDs where needed. At the moment, only Ethereum accounts
 * are supported with the EthereumAuthProvider. Additional accounts will be supported in the future.
 *
 * ```ts
 * import { DIDSession } from '@glazed/did-session'
 * import { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'
 *
 * const ethProvider = // import/get your web3 eth provider
 * const addresses = await ethProvider.enable()
 * const authProvider = new EthereumAuthProvider(ethProvider, addresses[0])
 *
 * const session = new DIDSession({ authProvider })
 * const did = await session.authorize()
 *
 * // Uses DIDs in ceramic & glaze libraries, ie
 * const ceramic = new CeramicClient()
 * ceramic.did = did
 *
 * // pass ceramic instance where needed
 *
 * ```
 *
 * You can serialize a session to store for later and then re-initialize. Currently sessions are valid
 * for 1 day by default.
 *
 *```ts
 * // Create session as above, store for later
 * const session = new DIDSession({ authProvider })
 * const did = await session.authorize()
 * const sessionString = session.serialize()
 *
 * // write/save session string where you want (ie localstorage)
 * // ...
 *
 * // Later re initialize session
 * const session2 = DIDSession.fromSession(authProvider, sessionString)
 * const ceramic = new CeramicClient()
 * ceramic.did = session2.getDID()
 * ```
 *
 * Additional helper functions are available to help you manage a session lifecycle and the user experience.
 *
 *```ts
 * // Check if authorized or created from existing session string
 * didsession.hasSession
 *
 * // Check if session expired
 * didsession.isExpired
 *
 * // Get resources session is authorized for
 * didsession.authorizations
 *
 * // Check number of seconds till expiration, may want to re auth user at a time before expiration
 * didsession.expiresInSecs
 * ```
 *
 * ### Typical usage pattern
 *
 * A typical pattern is to store a serialized session in local storage and load on use if available. Then
 * check that a session is still valid before making writes.
 *
 * ```ts
 * import { DIDSession } from '@glazed/did-session'
 * import { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'
 *
 * const ethProvider = // import/get your web3 eth provider
 * const addresses = await ethProvider.enable()
 * const authProvider = new EthereumAuthProvider(ethProvider, addresses[0])
 *
 * const loadSession = async(authProvider: EthereumAuthProvider):Promise<DIDSession> => {
 *  const sessionStr = localStorage.getItem('didsession')
 *  let session
 *
 *  if (sessionStr) {
 *    session = await DIDSession.fromSession(sessionStr, authProvider)
 *  }
 *
 *  if (!session || (session.hasSession && session.isExpired)) {
 *    session = new DIDSession({ authProvider })
 *    session.authorize()
 *    localStorage.setItem('didsession', session.serialize())
 *  }
 *
 *  return session
 * }
 *
 * const session = await loadSession(authProvider)
 * const ceramic = new CeramicClient()
 * ceramic.did = session.getDID()
 *
 * // pass ceramic instance where needed, ie glaze
 * // ...
 *
 * // before ceramic writes, check if session is still valid, if expired, create new
 * if (session.isExpired) {
 *   const session = loadSession(authProvider)
 *   ceramic.did = session.getDID()
 * }
 *
 * // continue to write
 * ```
 *
 * @module did-session
 */
import { DID } from 'dids';
import type { EthereumAuthProvider, CapabilityOpts } from '@ceramicnetwork/blockchain-utils-linking';
import type { Cacao } from 'ceramic-cacao';
export declare type SessionParams = {
    /**
     * An authProvider for the chain you wish to support, only ETH supported at moment
     */
    authProvider: EthereumAuthProvider;
    resources?: Array<string>;
    keySeed?: Uint8Array;
    cacao?: Cacao;
};
export declare function createDIDKey(seed?: Uint8Array): Promise<DID>;
/**
 * DID Session
 *
 * ```sh
 * import { DIDSession } from '@glazed/did-session'
 * ```
 */
export declare class DIDSession {
    #private;
    constructor(params: SessionParams);
    /**
     * Get authProvider
     */
    get authProvider(): EthereumAuthProvider;
    /**
     * Request authorization for session
     */
    authorize(capabilityOpts?: CapabilityOpts): Promise<DID>;
    initDID(didKey: DID, cacao: Cacao): Promise<DID>;
    /**
     * Get DID instance, if authorized
     */
    getDID(): DID;
    /**
     * Serialize session into string, can store and initalize the same session again while valid
     */
    serialize(): string;
    /**
     * Initialize a session from a serialized session string
     */
    static fromSession(session: string, authProvider: EthereumAuthProvider): Promise<DIDSession>;
    get hasSession(): boolean;
    /**
     * Determine if a session is expired or not
     */
    get isExpired(): boolean;
    /**
     * Number of seconds until a session expires
     */
    get expireInSecs(): number;
    /**
     * Get the list of resources a session is authorized for
     */
    get authorizations(): Array<string>;
    /**
     * Get the session CACAO
     */
    get cacao(): Cacao;
    /**
     * Determine if session is available and optionally if authorized for given resources
     */
    isAuthorized(resources?: Array<string>): boolean;
    /** DID string associated to the session instance. session.id == session.getDID().parent */
    get id(): string;
}
